// Operating Systems: sample code  (c) Tomáš Hudec
// Synchronization, Race Conditions
//
// Producer/Consumer Problem TO BE SOLVED
//
// (c) 2011 Tomáš Hudec
//
// Modified: 2011-12-08, 2013-11-27, 2014-02-12, 2014-01-29, 2016-01-28, 2016-11-03, 2018-11-15, 2020-10-17
//

/* Zadání

Vyřešte problém konzumentů a producentů
bez aktivního čekání
užitím posixových mutexů a semaforů nebo podmínkových proměnných.

Problémy jsou tři:
-- synchronizace při prázdném a plném skladu,
-- kritická sekce při vstupu do skladu.

Ošetřete chybové stavy hláškou o chybě a ukončením programu s návratovým
kódem různým od nuly.

Použijte vhodné komentáře.

Výsledný program pojmenujte producer_consumer_solved.c a vytvořte Makefile.

*/

/* Assignment

Solve the producer-consumer problem
with non-busy wait
using POSIX mutexes, semaphores or condition variables.

There are three problems:
-- synchronization if the shared storage buffer is empty and full,
-- race condition while entering the storage buffer.

Check return values and in case of error terminate the program
with non-zero exit code.

Use suitable comments.

Name the result program producer_consumer_solved.c and create a Makefile.

Compilation:
  gcc -D_REENTRANT producer_consumer.c -o producer_consumer -lpthread

*/

// We need to define _XOPEN_SOURCE >= 600 for access to barriers
// or _POSIX_C_SOURCE to 200112L

#if _XOPEN_SOURCE < 600
#	define _XOPEN_SOURCE 600	// for portability, use barriers
#endif

#include <stdio.h>	// printf(3), fflush(3)
#include <unistd.h>	// usleep(3), getopt(3)
#include <stdlib.h>	// srand(3), rand(3)
#include <stdbool.h>	// bool, true, false
#include <sys/time.h>	// gettimeofday(2)
#include <time.h>
#include <pthread.h>	// pthread_*
#include <string.h>	// memset(3)
// additional includes for synchronization and critical section


// limits
#define MAX_RANDOM_SLEEP_P_MS	   5
#define MAX_RANDOM_SLEEP_C_MS	  22
#define MIN_STORAGE_CAPACITY	   1
#define MAX_STORAGE_CAPACITY	  20
#define MAX_PRODUCERS		   4
#define MAX_CONSUMERS		  50

// defaults
#define DEFAULT_STORAGE_CAPACITY   5
#define DEFAULT_PRODUCERS	   2
#define DEFAULT_CONSUMERS	   1

// SHARED VARIABLES

// storage info: capacity and queue data
typedef struct {
	char	buf[MAX_STORAGE_CAPACITY];	// shared storage buffer
	int	capacity;	// storage buffer capacity
	int	in;		// index of next empty space
	int	out;		// index of first stored space
	int	count;		// the number of items stored
	// critical section and synchronization data
} shared_storage_t;

shared_storage_t storage;	// storage

// the number of producers and consumers
int total_producers = DEFAULT_PRODUCERS;
int total_consumers = DEFAULT_CONSUMERS;

// the items to be generated by each producer are characters
static char *toBeProducedData[MAX_PRODUCERS] = {
	"abcdefghijklmnopqrstuvwxyz",
	"ABCDEFGHIJKLMNOPQRSTUVWXYZ",
	"0123456789",
	"!@#$%^~&*()=+[]{};:,<.>/?",
};
#define EMPTY_SPACE_ITEM	'_'
#define QUIT_ITEM		'-'

int verbose = 0;
int parallel_start = 0;
int wait_factor_p = 1;
int wait_factor_c = 1;
pthread_barrier_t sync_start_barrier;

// prototypes
void *producer(void *);
void *consumer(void *);
void eval_params(int argc, char *argv[]);


// atexit function (resources release)

bool barrier_allocated = false;		// set to true if a barrier was allocated

void release_resources(void)
{
	// release system resources

	// destroy the barrier
	if (barrier_allocated) {	// destroy the barrier
		if (verbose > 2)
			printf("Releasing the barrier.\n");
		if (pthread_barrier_destroy(&sync_start_barrier))
			perror("pthread_barrier_destroy");
		else
			barrier_allocated = false;
	}
	return;
}


// MAIN

int main(int argc, char *argv[])
{
	struct timeval tv;
	int i;
	pthread_t consumer_ids[MAX_CONSUMERS];
	pthread_t producer_ids[MAX_PRODUCERS];
	int producer_args[MAX_PRODUCERS];
	int consumer_args[MAX_CONSUMERS];

	// initialize variables to default values
	storage.capacity = DEFAULT_STORAGE_CAPACITY;
	storage.in = 0;
	storage.out = 0;
	// initialize buffer with some reasonable values
	memset(storage.buf, EMPTY_SPACE_ITEM, sizeof(storage.buf));

	// evaluate options
	eval_params(argc, argv);

	// register the atexit function for resource release
	atexit(release_resources);

	// initialize critical section and synchronization variables


	// initialize a barrier
	if (parallel_start) {
		if (verbose > 2)
			printf("Initializing a barrier to %d.\n", total_consumers + total_producers);
		if (pthread_barrier_init(&sync_start_barrier, NULL, total_consumers + total_producers)) {
			perror("pthread_barrier_init");
			exit(EXIT_FAILURE);
		}
		barrier_allocated = true;	// the barrier was allocated
	}

	// initialize the random number generator
	gettimeofday(&tv, NULL);
	srand(tv.tv_usec + getpid());

	// run all consumers:
	if (verbose)
		printf("Creating %d consumer thread(s).\n", total_consumers);
	for (i = 0; i < total_consumers; ++i) {
		consumer_args[i] = i;
		if (pthread_create(&consumer_ids[i], NULL, consumer, &consumer_args[i])) {
			fprintf(stderr, "ERROR creating consumer thread %d.\n", i);
			return EXIT_FAILURE;
		}
	}

	// run all producers:
	if (verbose)
		printf("Creating %d producer thread(s).\n", total_producers);
	for (i = 0; i < total_producers; ++i) {
		producer_args[i] = i;
		if (pthread_create(&producer_ids[i], NULL, producer, &producer_args[i])) {
			fprintf(stderr, "ERROR creating producer thread %d.\n", i);
			return EXIT_FAILURE;
		}
	}

	// wait for all producers to finish
	if (verbose > 1)
		printf("\nWaiting for producer thread(s)...\n");
	for (i = 0; i < total_producers; ++i) {
		if (pthread_join(producer_ids[i], NULL)) {
			fprintf(stderr, "ERROR joining producer thread %d.\n", i);
			return EXIT_FAILURE;
		}
	}

	// let consumers know that it's done
	producer_args[0] = -total_consumers;
	if (pthread_create(&producer_ids[0], NULL, producer, &producer_args[0])) {
		fprintf(stderr, "ERROR creating producer thread %d.\n", -1);
		return EXIT_FAILURE;
	}
	if (pthread_join(producer_ids[0], NULL)) {
		fprintf(stderr, "ERROR joining producer thread %d.\n", -1);
		return EXIT_FAILURE;
	}

	// wait for all consumers to finish
	if (verbose > 1)
		printf("\nWaiting for consumer thread(s)...\n");
	for (i = 0; i < total_consumers; ++i) {
		if (pthread_join(consumer_ids[i], NULL)) {
			fprintf(stderr, "ERROR joining consumer thread %d.\n", i);
			return EXIT_FAILURE;
		}
	}

	printf("\n");

	// used resources are released using atexit(3)

	return EXIT_SUCCESS;
} // main


// sleep for a random amount of time (in milliseconds)

void simulate_work(int max_ms)
{
	usleep(1000 * (int) (1 + max_ms * 1.0 * (rand() / (RAND_MAX + 1.0))));
	return;
}


// producer

void *producer(void *arg)
{
	int i;
	int id = *(int *)arg;
	char *items;
	int consumers = 0;

	// negative id (special producer): -id = the number of consumers
	if (id < 0)
		consumers = -id;
	else
		items = toBeProducedData[id];

	if (verbose > 1) {
		if (consumers)
			printf("\nConsumer-terminator producer started, the number of consumers: %d.\n", consumers);
		else
			printf("\nProducer %d started.\n", id);
	}
	
	if (parallel_start && !consumers) {	// wait at the barrier
		switch (pthread_barrier_wait(&sync_start_barrier)) {
			case 0:
			case PTHREAD_BARRIER_SERIAL_THREAD:
				break;
			default:
				perror("producer pthread_barrier_wait");
				exit(EXIT_FAILURE);
		}
	}

	for (i = 0; consumers ? i < consumers : items[i]; ++i) {
		// simulate production
		if (!consumers)
			simulate_work(wait_factor_p * MAX_RANDOM_SLEEP_P_MS);

		// put given item to the storage and increment index pointer
		storage.buf[storage.in] = consumers ? QUIT_ITEM : items[i];
		storage.in = (storage.in + 1) % storage.capacity;
		storage.count++;
	}

	if (verbose > 1) {
		if (consumers)
			printf("\nConsumer-terminator producer exiting.\n");
		else
			printf("\nProducer %d exiting.\n", id);
	}
	
	return NULL;
}


// consumer

void *consumer(void *arg)
{
	int id = *(int *)arg;
	char item = '|';

	if (verbose > 1)
		printf("\nConsumer %d started.\n", id);
	
	if (parallel_start) {	// wait at the barrier
		switch (pthread_barrier_wait(&sync_start_barrier)) {
			case 0:
			case PTHREAD_BARRIER_SERIAL_THREAD:
				break;
			default:
				perror("consumer pthread_barrier_wait");
				exit(EXIT_FAILURE);
		}
	}

	while (1) {
		// get item from the storage
		item = storage.buf[storage.out];
		storage.out = (storage.out + 1) % storage.capacity;
		storage.count--;

		// is it all and should we quit?
		if (item == QUIT_ITEM)
			break;

		// simulate processing
		simulate_work(wait_factor_c * MAX_RANDOM_SLEEP_C_MS);

		// print the result
		printf("%c", item);
		fflush(stdout);
	}

	if (verbose > 1)
		printf("\nConsumer %d exiting.\n", id);
	
	return NULL;
}


// help

void usage(FILE *stream, char *self)
{
	fprintf(stream,
		"Usage:\n"
		"  %s -h\n"
		"  %s [-q|-v] [-w] [-c consumers] [-p producers] [-s storage_capacity] [-P factor] [-C factor]\n"
		"Purpose:\n"
		"  Simulation of producer-consumer problem.\n"
		"Options:\n"
		"  -h	this help\n"
		"  -v	increase verbosity (default is %d)\n"
		"  -q	decrease verbosity\n"
		"  -w	wait in threads -- synchronous start\n"
		"  -c #	set the number of consumer threads (%d, max. %d)\n"
		"  -p #	set the number of producer threads (%d, max. %d)\n"
		"  -s #	set the storage capacity (%d, min. %d, max. %d)\n"
		"  -C #	set the factor for consumer work simulation delay\n"
		"  -P #	set the factor for producer work simulation delay\n"
		"\n",
		self, self,
		verbose,
		total_consumers, MAX_CONSUMERS,
		total_producers, MAX_PRODUCERS,
		storage.capacity, 2, MAX_STORAGE_CAPACITY);
}


// evaluate options

void eval_params(int argc, char *argv[]) {
	int opt;

	opterr = 0;	// no error msg on unknown option, we care of this
	// evaluate options
	while ((opt = getopt(argc, argv, "hqvc:p:s:wP:C:")) != -1) {
		switch (opt) {
		// -c consumer_threads
		case 'c':
			total_consumers = atoi(optarg);
			if (total_consumers < 1 || total_consumers > MAX_CONSUMERS) {
				fprintf(stderr, "Consumer threads must be between 1 and %d.\n", MAX_CONSUMERS);
				exit(2);
			}
			break;
		// -p producer_threads
		case 'p':
			total_producers = atoi(optarg);
			if (total_producers < 1 || total_producers > MAX_PRODUCERS) {
				fprintf(stderr, "Producer threads must be between 1 and %d.\n", MAX_PRODUCERS);
				exit(2);
			}
			break;
		// -s storage_capacity
		case 's':
			storage.capacity = atoi(optarg);
			if (storage.capacity < MIN_STORAGE_CAPACITY || storage.capacity > MAX_STORAGE_CAPACITY) {
				fprintf(stderr, "Storage capacity must be between %d and %d.\n", MIN_STORAGE_CAPACITY, MAX_STORAGE_CAPACITY);
				exit(2);
			}
			break;
		// -w
		case 'w':
			parallel_start = 1;
			break;
		// -v
		case 'v':
			if (verbose < 100)
				++verbose;
			break;
		// -q
		case 'q':
			if (verbose > 0)
				--verbose;
			break;
		// -C wait_factor
		case 'C':
			wait_factor_c = atoi(optarg);
			if (wait_factor_c < 0 || wait_factor_c > 1000) {
				fprintf(stderr, "The wait factor must be between %d and %d.\n", 0, 1000);
				exit(2);
			}
			break;
		// -P wait_factor
		case 'P':
			wait_factor_p = atoi(optarg);
			if (wait_factor_p < 0 || wait_factor_p > 1000) {
				fprintf(stderr, "The wait factor must be between %d and %d.\n", 0, 1000);
				exit(2);
			}
			break;
		// -h
		case 'h':
			usage(stdout, argv[0]);
			exit(EXIT_SUCCESS);
		// unknown option
		default:
			fprintf(stderr, "%c: unknown option.\n", optopt);
			usage(stderr, argv[0]);
			exit(2);
			break;
		}
	}
	return;
} // eval_params

// EOF
